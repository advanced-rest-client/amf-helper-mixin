<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, minimum-scale=1, initial-scale=1, user-scalable=yes">
  <title>amf-helper-mixin test</title>
  <script src="../../webcomponentsjs/webcomponents-loader.js"></script>
  <script src="../../web-component-tester/browser.js"></script>
  <link rel="import" href="../../arc-polyfills/arc-polyfills.html">
  <link rel="import" href="test-element.html">
  <script src="amf-loader.js"></script>
</head>
<body>
  <test-fixture id="Basic">
    <template>
      <test-element></test-element>
    </template>
  </test-fixture>

  <script>
  /* global AmfLoader */
  suite('amf-helper-mixin', () => {
    let element;
    let model;
    suiteSetup(() => {
      return AmfLoader.load()
      .then((data) => {
        model = data;
      });
    });


    suite('_ensureAmfModel()', () => {
      setup(() => {
        element = fixture('Basic');
      });

      test('Returns undefined if no argument', () => {
        assert.isUndefined(element._ensureAmfModel());
      });

      test('Returns model for array model value', () => {
        const result = element._ensureAmfModel(model);
        assert.typeOf(result, 'object');
      });

      test('Returns model for object model value', () => {
        const result = element._ensureAmfModel(model[0]);
        assert.typeOf(result, 'object');
      });

      test('Returns undefined when no type', () => {
        const result = element._ensureAmfModel([{}]);
        assert.isUndefined(result);
      });

      test('Namespace property is set', () => {
        assert.typeOf(element.ns, 'object');
      });
    });

    suite('AMF keys namespace', () => {
      test('Global variable is set', () => {
        assert.typeOf(window.ApiElements.Amf, 'object');
      });

      test('ns variable is set', () => {
        assert.typeOf(window.ApiElements.Amf.ns, 'object');
      });

      test('ns has all keys', () => {
        const keys = Object.keys(window.ApiElements.Amf.ns);
        const compare = ['raml', 'w3', 'schema'];
        assert.deepEqual(keys, compare);
      });

      test('raml properties are set', () => {
        const r = ApiElements.Amf.ns.raml;
        assert.equal(r.name, 'http://a.ml/');
        assert.typeOf(r.vocabularies, 'object');
      });

      test('raml cannot be changed', () => {
        window.ApiElements.Amf.ns.raml = 'test';
        assert.typeOf(window.ApiElements.Amf.ns.raml, 'object');
      });

      test('vocabularies properties are set', () => {
        const v = ApiElements.Amf.ns.raml.vocabularies;
        const key = 'http://a.ml/vocabularies/';
        assert.equal(v.name, key);
        assert.equal(v.document, key + 'document#');
        assert.equal(v.http, key + 'http#');
        assert.equal(v.security, key + 'security#');
        assert.equal(v.shapes, key + 'shapes#');
        assert.equal(v.data, key + 'data#');
      });

      test('vocabularies cannot be changed', () => {
        window.ApiElements.Amf.ns.raml.vocabularies = 'test';
        assert.typeOf(window.ApiElements.Amf.ns.raml.vocabularies, 'object');
      });

      test('w3 properties are set', () => {
        const r = ApiElements.Amf.ns.w3;
        assert.equal(r.name, 'http://www.w3.org/');
        assert.typeOf(r.hydra, 'object');
        assert.typeOf(r.shacl, 'object');
        assert.equal(r.xmlSchema, 'http://www.w3.org/2001/XMLSchema#');
      });

      test('w3 cannot be changed', () => {
        window.ApiElements.Amf.ns.w3 = 'test';
        assert.typeOf(window.ApiElements.Amf.ns.w3, 'object');
      });

      test('hydra properties are set', () => {
        const h = ApiElements.Amf.ns.w3.hydra;
        const key = 'http://www.w3.org/ns/hydra/';
        assert.equal(h.name, key);
        assert.equal(h.core, key + 'core#');
        assert.equal(h.supportedOperation, key + 'core#supportedOperation');
      });

      test('hydra cannot be changed', () => {
        window.ApiElements.Amf.ns.w3.hydra = 'test';
        assert.typeOf(window.ApiElements.Amf.ns.w3.hydra, 'object');
      });

      test('shacl properties are set', () => {
        const s = ApiElements.Amf.ns.w3.shacl;
        const key = 'http://www.w3.org/ns/shacl#';
        assert.equal(s.name, key);
        [
          'in', 'defaultValueStr', 'pattern', 'minInclusive', 'maxInclusive',
          'multipleOf', 'minLength', 'maxLength', 'fileType'
        ]
        .forEach((name) => {
          assert.equal(s[name], key + name);
        });
        assert.equal(s.shape, key + 'Shape');
      });

      test('shacl cannot be changed', () => {
        window.ApiElements.Amf.ns.w3.shacl = 'test';
        assert.typeOf(window.ApiElements.Amf.ns.w3.shacl, 'object');
      });

      test('schema properties are set', () => {
        const s = ApiElements.Amf.ns.schema;
        const key = 'http://schema.org/';
        assert.equal(s.name, key);
        assert.equal(s.schemaName, key + 'name');
        assert.equal(s.desc, key + 'description');
        assert.equal(s.doc, key + 'documentation');
        assert.equal(s.webApi, key + 'WebAPI');
        assert.equal(s.creativeWork, key + 'CreativeWork');
        [
          'displayName', 'title'
        ]
        .forEach((name) => {
          assert.equal(s[name], key + name);
        });
      });

      test('schema cannot be changed', () => {
        window.ApiElements.Amf.ns.schema = 'test';
        assert.typeOf(window.ApiElements.Amf.ns.schema, 'object');
      });

      test('Global object is also accessible via element API', () => {
        element = fixture('Basic');
        assert.isTrue(element.ns === window.ApiElements.Amf.ns);
      });
    });

    suite('_getValue()', () => {
      setup(() => {
        element = fixture('Basic');
      });

      test('Returns undefined if no arguments', () => {
        assert.isUndefined(element._getValue());
      });

      test('Returns undefined if no model argument', () => {
        assert.isUndefined(element._getValue(undefined, 'test'));
      });

      test('Returns undefined if no key argument', () => {
        assert.isUndefined(element._getValue({}));
      });

      test('Returns undefined if no key in object', () => {
        assert.isUndefined(element._getValue({
          a: [],
          b: []
        }, 'c'));
      });

      test('Returns undefined if no value in value array', () => {
        assert.isUndefined(element._getValue({
          a: []
        }, 'a'));
      });

      test('Returns the value', () => {
        assert.equal(element._getValue({
          a: [{
            '@value': 'test'
          }]
        }, 'a'), 'test');
      });
    });

    suite('_getValueArray()', () => {
      setup(() => {
        element = fixture('Basic');
      });

      test('Returns undefined if no arguments', () => {
        assert.isUndefined(element._getValueArray());
      });

      test('Returns undefined if no model argument', () => {
        assert.isUndefined(element._getValueArray(undefined, 'test'));
      });

      test('Returns undefined if no key argument', () => {
        assert.isUndefined(element._getValueArray({}));
      });

      test('Returns undefined if no key in object', () => {
        assert.isUndefined(element._getValueArray({
          a: [],
          b: []
        }, 'c'));
      });

      test('Returns empty array if no value in value array', () => {
        assert.deepEqual(element._getValueArray({
          a: []
        }, 'a'), []);
      });

      test('Returns the values', () => {
        assert.deepEqual(element._getValueArray({
          a: [{
            '@value': 'test'
          }, {
            '@value': 'test2'
          }]
        }, 'a'), ['test', 'test2']);
      });
    });

    suite('_hasType()', () => {
      setup(() => {
        element = fixture('Basic');
      });

      test('Returns false if no arguments', () => {
        assert.isFalse(element._hasType());
      });

      test('Returns false if no model argument', () => {
        assert.isFalse(element._hasType(undefined, 'test'));
      });

      test('Returns false if no key argument', () => {
        assert.isFalse(element._hasType({}));
      });

      test('Returns false if type does not match', () => {
        assert.isFalse(element._hasType({
          '@type': ['a', 'b']
        }, 'c'));
      });

      test('Returns true if type does match', () => {
        assert.isTrue(element._hasType({
          '@type': ['a', 'b', 'c']
        }, 'c'));
      });
    });

    suite('_hasProperty()', () => {
      setup(() => {
        element = fixture('Basic');
      });

      test('Returns false if no arguments', () => {
        assert.isFalse(element._hasProperty());
      });

      test('Returns false if no model argument', () => {
        assert.isFalse(element._hasProperty(undefined, 'test'));
      });

      test('Returns false if no key argument', () => {
        assert.isFalse(element._hasProperty({}));
      });

      test('Returns false if type does not have property', () => {
        assert.isFalse(element._hasProperty({
          a: 'test',
          b: 'test'
        }, 'c'));
      });

      test('Returns true if have a property', () => {
        assert.isTrue(element._hasProperty({
          a: 'test',
          b: 'test',
          c: 'test'
        }, 'c'));
      });
    });

    suite('_computePropertyArray()', () => {
      setup(() => {
        element = fixture('Basic');
      });

      test('Returns undefined if no arguments', () => {
        assert.isUndefined(element._computePropertyArray());
      });

      test('Returns undefined if no model argument', () => {
        assert.isUndefined(element._computePropertyArray(undefined, 'test'));
      });

      test('Returns undefined if no key argument', () => {
        assert.isUndefined(element._computePropertyArray({}));
      });

      test('Returns undefined if property is not an array', () => {
        assert.isUndefined(element._computePropertyArray({
          test: true
        }, 'test'));
      });

      test('Returns undefined if property is not an array', () => {
        assert.deepEqual(element._computePropertyArray({
          test: ['a', 'b', 'c']
        }, 'test'), ['a', 'b', 'c']);
      });
    });

    suite('_computePropertyObject()', () => {
      setup(() => {
        element = fixture('Basic');
      });

      test('Returns undefined if no arguments', () => {
        assert.isUndefined(element._computePropertyObject());
      });

      test('Returns undefined if no model argument', () => {
        assert.isUndefined(element._computePropertyObject(undefined, 'test'));
      });

      test('Returns undefined if no key argument', () => {
        assert.isUndefined(element._computePropertyObject({}));
      });

      test('Returns bolean value', () => {
        assert.isTrue(element._computePropertyObject({
          test: [true]
        }, 'test'));

        assert.isFalse(element._computePropertyObject({
          test: [false]
        }, 'test'));
      });

      test('Returns null value', () => {
        assert.equal(element._computePropertyObject({
          test: [null]
        }, 'test'), null);
      });

      test('Returns string value', () => {
        assert.equal(element._computePropertyObject({
          test: ['test-value']
        }, 'test'), 'test-value');
      });

      test('Returns number value', () => {
        assert.equal(element._computePropertyObject({
          test: [123]
        }, 'test'), 123);
      });

      test('Returns 0 value', () => {
        assert.equal(element._computePropertyObject({
          test: [0]
        }, 'test'), 0);
      });
    });

    suite('_computeHasStringValue()', () => {
      setup(() => {
        element = fixture('Basic');
      });

      test('Returns false if no argument', () => {
        assert.isFalse(element._computeHasStringValue());
      });

      test('Returns false if empty string', () => {
        assert.isFalse(element._computeHasStringValue(''));
      });

      test('Returns true if not empty string', () => {
        assert.isTrue(element._computeHasStringValue('a'));
      });

      test('Returns true if an object', () => {
        assert.isTrue(element._computeHasStringValue({'a': 'b'}));
      });

      test('Returns true if a number', () => {
        assert.isTrue(element._computeHasStringValue(125));
        assert.isTrue(element._computeHasStringValue(0));
      });
    });

    suite('_computeHasStringValue()', () => {
      setup(() => {
        element = fixture('Basic');
      });

      test('Returns false if no argument', () => {
        assert.isFalse(element._computeHasStringValue());
      });

      test('Returns false if empty string', () => {
        assert.isFalse(element._computeHasStringValue(''));
      });

      test('Returns true if not empty string', () => {
        assert.isTrue(element._computeHasStringValue('a'));
      });

      test('Returns true if an object', () => {
        assert.isTrue(element._computeHasStringValue({'a': 'b'}));
      });

      test('Returns true if a number', () => {
        assert.isTrue(element._computeHasStringValue(125));
        assert.isTrue(element._computeHasStringValue(0));
      });
    });

    suite('_computeHasArrayValue()', () => {
      setup(() => {
        element = fixture('Basic');
      });

      test('Returns false if no argument', () => {
        assert.isFalse(element._computeHasArrayValue());
      });

      test('Returns false if empty array', () => {
        assert.isFalse(element._computeHasArrayValue([]));
      });

      test('Returns false if not array', () => {
        assert.isFalse(element._computeHasArrayValue('a'));
      });

      test('Returns true if array has items', () => {
        assert.isTrue(element._computeHasStringValue(['a']));
      });
    });

    suite('_computeDescription()', () => {
      setup(() => {
        element = fixture('Basic');
      });

      test('Returns undefined if no argument', () => {
        assert.isUndefined(element._computeDescription());
      });

      test('Returns undefined if empty object', () => {
        assert.isUndefined(element._computeDescription({}));
      });

      test('Returns undefined if no description key', () => {
        assert.isUndefined(element._computeDescription({
          a: 'test'
        }));
      });

      test('Returns undefined if no description key', () => {
        assert.equal(element._computeDescription({
          'http://schema.org/description': [{
            '@value': ['test']
          }]
        }), 'test');
      });
    });

    suite('_computeEncodes()', () => {
      setup(() => {
        element = fixture('Basic');
      });

      test('Returns undefined if no argument', () => {
        assert.isUndefined(element._computeEncodes());
      });

      test('Returns undefined if no encodes', () => {
        assert.isUndefined(element._computeEncodes({}));
      });

      test('Returns an array from AMF model', () => {
        const result = element._computeEncodes(model);
        assert.typeOf(result, 'object');
      });
    });

    suite('_computeDeclares()', () => {
      setup(() => {
        element = fixture('Basic');
      });

      test('Returns undefined if no argument', () => {
        assert.isUndefined(element._computeDeclares());
      });

      test('Returns undefined if no declares', () => {
        assert.isUndefined(element._computeDeclares({}));
      });

      test('Returns an array from AMF model', () => {
        const result = element._computeDeclares(model);
        assert.typeOf(result, 'array');
      });

      test('Returns all items in the array', () => {
        const result = element._computeDeclares(model);
        assert.lengthOf(result, 17);
      });
    });

    suite('_computeReferences()', () => {
      setup(() => {
        element = fixture('Basic');
      });

      test('Returns undefined if no argument', () => {
        assert.isUndefined(element._computeReferences());
      });

      test('Returns undefined if no references', () => {
        assert.isUndefined(element._computeReferences({}));
      });

      test('Returns an array from AMF model', () => {
        const result = element._computeReferences(model);
        assert.typeOf(result, 'array');
      });

      test('Returns all items in the array', () => {
        const result = element._computeReferences(model);
        assert.lengthOf(result, 8);
      });
    });

    suite('_computeWebApi()', () => {
      setup(() => {
        element = fixture('Basic');
      });

      test('Returns undefined if no argument', () => {
        assert.isUndefined(element._computeWebApi());
      });

      test('Returns undefined if no encodes', () => {
        assert.isUndefined(element._computeWebApi({}));
      });

      test('Returns an object from AMF model', () => {
        const result = element._computeWebApi(model);
        assert.typeOf(result, 'object');
      });
    });

    suite('_computeServer()', () => {
      setup(() => {
        element = fixture('Basic');
      });

      test('Returns undefined if no argument', () => {
        assert.isUndefined(element._computeServer());
      });

      test('Returns undefined if no encodes', () => {
        assert.isUndefined(element._computeServer({}));
      });

      test('Returns an object from AMF model', () => {
        const result = element._computeServer(model);
        assert.typeOf(result, 'object');
      });
    });

    suite('_computeProtocols()', () => {
      setup(() => {
        element = fixture('Basic');
      });

      test('Returns undefined if no argument', () => {
        assert.isUndefined(element._computeProtocols());
      });

      test('Returns array with values', () => {
        const result = element._computeProtocols(model);
        assert.typeOf(result, 'array');
        assert.deepEqual(result, ['HTTPS']);
      });
    });

    suite('_computeExpects()', () => {
      let operation;
      let noExpectsOperation;
      suiteSetup(() => {
        element = fixture('Basic');
        const endpoint = element._computeEndpointModel(
          element._computeWebApi(model),
          'file://test/demo-api/demo-api.raml#/web-api/end-points/%2Fchanges%2Fwatch'
        );
        operation = endpoint['http://www.w3.org/ns/hydra/core#supportedOperation'][0];
        noExpectsOperation = endpoint['http://www.w3.org/ns/hydra/core#supportedOperation'][1];
      });

      test('Returns undefined if no argument', () => {
        assert.isUndefined(element._computeExpects());
      });

      test('Returns undefined if operation does not have "expects"', () => {
        assert.isUndefined(element._computeExpects(noExpectsOperation));
      });

      test('Returns object for an operation', () => {
        const result = element._computeExpects(operation);
        assert.typeOf(result, 'object');
      });
    });

    suite('_computeEndpoints()', () => {
      let webApi;
      suiteSetup(() => {
        element = fixture('Basic');
        webApi = element._computeWebApi(model);
      });

      test('Returns a loist of endpoints', () => {
        const result = element._computeEndpoints(webApi);
        assert.typeOf(result, 'array');
        assert.lengthOf(result, 34);
      });
    });

    suite('_computeEndpointModel()', () => {
      let webApi;
      suiteSetup(() => {
        element = fixture('Basic');
        webApi = element._computeWebApi(model);
      });

      test('Returns undefined if no arguments', () => {
        assert.isUndefined(element._computeEndpointModel());
      });

      test('Returns undefined if no model argument', () => {
        assert.isUndefined(element._computeEndpointModel(undefined, 'test'));
      });

      test('Returns undefined if no selected argument', () => {
        assert.isUndefined(element._computeEndpointModel(webApi));
      });

      test('Returns undefined if selection does not exists', () => {
        assert.isUndefined(element._computeEndpointModel(webApi, 'hello'));
      });

      test('Returns object for endpoint', () => {
        const result = element._computeEndpointModel(webApi,
          'file://test/demo-api/demo-api.raml#/web-api/end-points/%2Fchanges%2Fwatch');
        assert.typeOf(result, 'object');
        assert.equal(result['@type'][0], 'http://a.ml/vocabularies/http#EndPoint');
      });
    });

    suite('_computeMethodModel()', () => {
      let webApi;
      suiteSetup(() => {
        element = fixture('Basic');
        webApi = element._computeWebApi(model);
      });

      test('Returns undefined if no arguments', () => {
        assert.isUndefined(element._computeMethodModel());
      });

      test('Returns undefined if no model argument', () => {
        assert.isUndefined(element._computeMethodModel(undefined, 'test'));
      });

      test('Returns undefined if no selected argument', () => {
        assert.isUndefined(element._computeMethodModel(webApi));
      });

      test('Returns undefined if selection does not exists', () => {
        assert.isUndefined(element._computeMethodModel(webApi, 'hello'));
      });

      test('Returns object for method', () => {
        const result = element._computeMethodModel(webApi,
        'file://test/demo-api/demo-api.raml#/web-api/end-points/%2FpermissionIds%2F%7Bemail%7D/get');
        assert.typeOf(result, 'object');
        assert.equal(result['@type'][0], 'http://www.w3.org/ns/hydra/core#Operation');
      });
    });

    suite('_computeType()', () => {
      let references;
      let declares;
      suiteSetup(() => {
        element = fixture('Basic');
        declares = element._computeDeclares(model);
        references = element._computeReferences(model);
      });

      test('Returns undefined if no arguments', () => {
        assert.isUndefined(element._computeType());
      });

      test('Returns undefined if no model argument', () => {
        assert.isUndefined(element._computeType(undefined, undefined, 'test'));
      });

      test('Returns undefined if no selected argument', () => {
        assert.isUndefined(element._computeType(declares, references));
      });

      test('Returns undefined if selection does not exists', () => {
        assert.isUndefined(element._computeType(declares, references, 'not-here'));
      });

      test('Returns type in declarations', () => {
        const result = element._computeType(declares, undefined,
          'file://test/demo-api/types/app-person.raml#/type');
        assert.typeOf(result, 'object');
        assert.equal(result['@type'][0], 'http://www.w3.org/ns/shacl#NodeShape');
      });

      test('Returns type in references (library)', () => {
        const result = element._computeType(declares, references,
          'file://test/demo-api/library.raml#/declarations/types/TypeFromLibray');
        assert.typeOf(result, 'object');
        assert.equal(result['@type'][0], 'http://www.w3.org/ns/shacl#NodeShape');
      });
    });

    suite('_getLinkTarget()', () => {
      // let webApi;
      suiteSetup(() => {
        element = fixture('Basic');
        element.amfModel = model;
        // webApi = element._computeWebApi(model);
      });

      test('Computes reference', () => {
        const result = element._getLinkTarget(model,
          'file://test/demo-api/demo-api.raml#/declarations/types/SchemaPerson');
        assert.typeOf(result, 'object');
      });

      test('Reference is resolved', () => {
        const result = element._getLinkTarget(model,
          'file://test/demo-api/demo-api.raml#/declarations/types/SchemaPerson');
        assert.typeOf(result['http://a.ml/vocabularies/document#raw'], 'array');
      });

      test('Deep reference is resolved', () => {
        const result = element._getLinkTarget(model,
          'file://test/demo-api/demo-api.raml#/declarations/types/SchemaPerson');
        const example = result['http://a.ml/vocabularies/document#examples'][0];
        assert.typeOf(example['http://a.ml/vocabularies/document#structuredValue'], 'array');
      });
    });

    suite('_getReferenceId()', () => {
      suiteSetup(() => {
        element = fixture('Basic');
        element.amfModel = model;
      });

      test('Computes reference', () => {
        const result = element._getReferenceId(model,
          'file://test/demo-api/schemas/person.json#/external');
        assert.typeOf(result, 'object');
      });
    });

    suite('_resolve()', () => {
      let webApi;
      suiteSetup(() => {
        element = fixture('Basic');
        element.amfModel = model;
        webApi = element._computeWebApi(model);
      });

      test('Resolves link target', () => {
        const endpoint = element._computeEndpointModel(webApi,
          'file://test/demo-api/demo-api.raml#/web-api/end-points/%2FreferenceId');
        const op = endpoint['http://www.w3.org/ns/hydra/core#supportedOperation'][0];
        const expects = op['http://www.w3.org/ns/hydra/core#expects'][0];
        const payload = expects['http://a.ml/vocabularies/http#payload'][0];
        const schema = payload['http://a.ml/vocabularies/http#schema'][0];
        const result = element._resolve(schema);
        assert.typeOf(result['http://www.w3.org/ns/shacl#name'], 'array');
        assert.typeOf(result['http://a.ml/vocabularies/document#raw'], 'array');
      });
    });
  });
  </script>
</body>
</html>
