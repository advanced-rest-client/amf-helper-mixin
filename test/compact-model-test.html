<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, minimum-scale=1, initial-scale=1, user-scalable=yes">
  <title>amf-helper-mixin test</title>

  <script src="../node_modules/@webcomponents/webcomponentsjs/webcomponents-loader.js"></script>
  <script src="../node_modules/@polymer/test-fixture/test-fixture.js"></script>
  <script src="../node_modules/mocha/mocha.js"></script>
  <script src="../node_modules/chai/chai.js"></script>
  <script src="../node_modules/wct-mocha/wct-mocha.js"></script>

  <!-- <script type="module" src="../../../arc-polyfills/arc-polyfills.js"></script> -->
  <script type="module" src="./test-element.js"></script>
  <script src="./amf-loader.js"></script>
</head>
<body>
  <test-fixture id="Basic">
    <template>
      <test-element></test-element>
    </template>
  </test-fixture>

  <script type="module">
  import {ns as AmfNamespace} from '../amf-helper-mixin.js';
// import '../../../arc-polyfills/arc-polyfills.js';
// import './test-element.js';
/* global AmfLoader */
suite('Compact model tests', () => {
  let element;
  let model;
  suiteSetup(() => {
    return AmfLoader.load({
      isCompact: true
    })
    .then((data) => {
      model = data;
    });
  });

  suite('_getAmfKey()', function() {
    setup(() => {
      element = fixture('Basic');
    });
    const key = 'http://schema.org/description';
    test('Returns a value from context', function() {
      element.amfModel = model;
      const result = element._getAmfKey(key);
      assert.equal(result, 'schema-org:description');
    });

    test('Returns the key if no AMF', function() {
      const result = element._getAmfKey(key);
      assert.equal(result, key);
    });

    test('Returns the key if value not found', function() {
      const result = element._getAmfKey('non-existing');
      assert.equal(result, 'non-existing');
    });
  });

  suite('_ensureAmfModel()', () => {
    setup(() => {
      element = fixture('Basic');
      element.amfModel = model;
    });

    test('Returns model', () => {
      const result = element._ensureAmfModel(model);
      assert.typeOf(result, 'object');
    });
  });

  suite('_getValue()', () => {
    setup(() => {
      element = fixture('Basic');
    });

    test('Returns the value', () => {
      element.amfModel = model;
      const key = 'http://a.ml/vocabularies/http#scheme';
      const result = element._getValue({
        'raml-http:scheme': [{
          '@value': 'test'
        }]
      }, key);
      assert.equal(result, 'test');
    });

    test('Returns undefined if no model', () => {
      const key = 'http://a.ml/vocabularies/http#scheme';
      const result = element._getValue({
        'raml-http:scheme': [{
          '@value': 'test'
        }]
      }, key);
      assert.isUndefined(result);
    });
  });

  suite('_getValueArray()', () => {
    setup(() => {
      element = fixture('Basic');
    });

    test('Returns the values', () => {
      element.amfModel = model;
      const key = 'http://a.ml/vocabularies/http#scheme';
      const result = element._getValueArray({
        'raml-http:scheme': [{
          '@value': 'test'
        }, {
          '@value': 'test2'
        }]
      }, key);
      assert.deepEqual(result, ['test', 'test2']);
    });

    test('Returns undefined if no model', () => {
      const key = 'http://a.ml/vocabularies/http#scheme';
      const result = element._getValueArray({
        'raml-http:scheme': [{
          '@value': 'test'
        }, {
          '@value': 'test2'
        }]
      }, key);
      assert.isUndefined(result);
    });
  });

  suite('_hasType()', () => {
    setup(() => {
      element = fixture('Basic');
      element.amfModel = model;
    });

    test('Returns true for compact type', () => {
      assert.isTrue(element._hasType({
        '@type': ['raml-shapes:Shape']
      }, 'http://a.ml/vocabularies/shapes#Shape'));
    });
  });

  suite('_hasProperty()', () => {
    setup(() => {
      element = fixture('Basic');
      element.amfModel = model;
    });

    test('Returns true if have a property', () => {
      const prop = 'http://a.ml/vocabularies/shapes#items';
      assert.isTrue(element._hasProperty({
        'a': 'test',
        'b': 'test',
        'raml-shapes:items': 'test'
      }, prop));
    });
  });

  suite('_computePropertyArray()', () => {
    setup(() => {
      element = fixture('Basic');
      element.amfModel = model;
    });

    test('Returns array for an item', () => {
      const result = element._computePropertyArray({
        'doc:references': ['a', 'b', 'c']
      }, 'http://a.ml/vocabularies/document#references');
      assert.deepEqual(result, ['a', 'b', 'c']);
    });
  });

  suite('_computeDescription()', () => {
    setup(() => {
      element = fixture('Basic');
      element.amfModel = model;
    });

    test('Returns undefined if no description key', () => {
      assert.equal(element._computeDescription({
        'schema-org:description': [{
          '@value': ['test']
        }]
      }), 'test');
    });
  });

  suite('_computeEncodes()', () => {
    setup(() => {
      element = fixture('Basic');
      element.amfModel = model;
    });

    test('Returns an object from AMF model', () => {
      const result = element._computeEncodes(model);
      assert.typeOf(result, 'object');
    });
  });

  suite('_computeDeclares()', () => {
    setup(() => {
      element = fixture('Basic');
      element.amfModel = model;
    });

    test('Returns an array from AMF model', () => {
      const result = element._computeDeclares(model);
      assert.typeOf(result, 'array');
    });

    test('Returns all items in the array', () => {
      const result = element._computeDeclares(model);
      assert.lengthOf(result, 17);
    });
  });

  suite('_computeReferences()', () => {
    setup(() => {
      element = fixture('Basic');
      element.amfModel = model;
    });

    test('Returns an array from AMF model', () => {
      const result = element._computeReferences(model);
      assert.typeOf(result, 'array');
    });

    test('Returns all items in the array', () => {
      const result = element._computeReferences(model);
      assert.lengthOf(result, 8);
    });
  });

  suite('_computeWebApi()', () => {
    setup(() => {
      element = fixture('Basic');
      element.amfModel = model;
    });

    test('Returns an object from AMF model', () => {
      const result = element._computeWebApi(model);
      assert.typeOf(result, 'object');
    });
  });

  suite('_computeServer()', () => {
    setup(() => {
      element = fixture('Basic');
      element.amfModel = model;
    });

    test('Returns an object from AMF model', () => {
      const result = element._computeServer(model);
      assert.typeOf(result, 'object');
    });
  });

  suite('_computeProtocols()', () => {
    setup(() => {
      element = fixture('Basic');
      element.amfModel = model;
    });

    test('Returns array with values', () => {
      const result = element._computeProtocols(model);
      assert.typeOf(result, 'array');
      assert.deepEqual(result, ['HTTPS']);
    });
  });

  suite('_computeExpects()', () => {
    let operation;
    let noExpectsOperation;
    suiteSetup(() => {
      element = fixture('Basic');
      element.amfModel = model;
      const webApi = element._computeWebApi(model);
      const endpoint = element._computeEndpointByPath(webApi, '/changes/watch');
      const key = element._getAmfKey(AmfNamespace.w3.hydra.supportedOperation);
      operation = endpoint[key][0];
      noExpectsOperation = endpoint[key][1];
    });

    test('Returns undefined if operation does not have "expects"', () => {
      assert.isUndefined(element._computeExpects(noExpectsOperation));
    });

    test('Returns object for an operation', () => {
      const result = element._computeExpects(operation);
      assert.typeOf(result, 'object');
    });
  });

  suite('_computeEndpoints()', () => {
    let webApi;
    suiteSetup(() => {
      element = fixture('Basic');
      element.amfModel = model;
      webApi = element._computeWebApi(model);
    });

    test('Returns a loist of endpoints', () => {
      const result = element._computeEndpoints(webApi);
      assert.typeOf(result, 'array');
      assert.lengthOf(result, 34);
    });
  });

  suite('_computeEndpointModel()', () => {
    let webApi;
    suiteSetup(() => {
      element = fixture('Basic');
      element.amfModel = model;
      webApi = element._computeWebApi(model);
    });

    test('Returns object for endpoint', () => {
      const endpoint = element._computeEndpointByPath(webApi, '/changes/watch');
      const id = endpoint['@id'];
      const result = element._computeEndpointModel(webApi, id);
      assert.typeOf(result, 'object');
      assert.equal(result['@type'][0], 'raml-http:EndPoint');
    });
  });

  suite('_computeMethodModel()', () => {
    let webApi;
    suiteSetup(() => {
      element = fixture('Basic');
      element.amfModel = model;
      webApi = element._computeWebApi(model);
    });

    test('Returns object for method', () => {
      const endpoint = element._computeEndpointByPath(webApi, '/permissionIds/{email}');
      let op = element._computeOperations(webApi, endpoint['@id']);
      if (op instanceof Array) {
        op = op[0];
      }
      const result = element._computeMethodModel(webApi, op['@id']);
      assert.typeOf(result, 'object');
      assert.equal(result['@type'][0], 'hydra:Operation');
    });
  });

  suite('_computeType()', () => {
    let references;
    let declares;
    suiteSetup(() => {
      element = fixture('Basic');
      element.amfModel = model;
      declares = element._computeDeclares(model);
      references = element._computeReferences(model);
    });

    test('Returns type in declarations', () => {
      const id = declares[1]['@id']; // Node shape.
      const result = element._computeType(declares, undefined, id);
      assert.typeOf(result, 'object');
      assert.equal(result['@type'][0], 'shacl:NodeShape');
    });

    test('Returns type in references (library)', () => {
      let ref = references[4]['doc:declares'];
      if (ref instanceof Array) {
        ref = ref[0];
      }
      if (ref instanceof Array) {
        ref = ref[0];
      }
      const id = ref['@id'];
      const result = element._computeType(declares, references, id);
      assert.typeOf(result, 'object');
      assert.equal(result['@type'][0], 'shacl:NodeShape');
    });
  });

  suite('_getLinkTarget()', () => {
    let resolved;
    suiteSetup(() => {
      element = fixture('Basic');
      element.amfModel = model;
      const declares = element._computeDeclares(model);
      const schemaId = declares[0]['@id'];
      resolved = element._getLinkTarget(model, schemaId);
    });

    test('Computes the reference', () => {
      assert.typeOf(resolved, 'object');
    });

    test('Reference is resolved', () => {
      const itemsKey = element._getAmfKey('http://a.ml/vocabularies/shapes#items');
      const nameKey = element._getAmfKey('http://schema.org/name');
      const shape = resolved[itemsKey][0];
      assert.equal(shape[nameKey][0]['@value'], 'Pic');
    });
  });

  suite('_getReferenceId()', () => {
    let refId;
    suiteSetup(() => {
      element = fixture('Basic');
      element.amfModel = model;
      const ref = element._computeReferences(model)[1];
      const enc = element._computeEncodes(ref);
      refId = enc['@id'];
    });

    test('Computes reference', () => {
      const result = element._getReferenceId(model, refId);
      assert.typeOf(result, 'object');
      assert.equal(result['@type'][0], 'doc:ExternalDomainElement');
    });
  });

  suite('_resolve()', () => {
    let webApi;
    suiteSetup(() => {
      element = fixture('Basic');
      element.amfModel = model;
      webApi = element._computeWebApi(model);
    });

    test('Resolves link target', () => {
      const endpoint = element._computeEndpointByPath(webApi, '/referenceId');
      const soKey = element._getAmfKey(AmfNamespace.w3.hydra.supportedOperation);
      const op = element._ensureArray(endpoint[soKey])[0];
      const expects = element._ensureArray(
        op[element._getAmfKey('http://www.w3.org/ns/hydra/core#expects')])[0];
      const payload = element._ensureArray(
        expects[element._getAmfKey('http://a.ml/vocabularies/http#payload')])[0];
      const schema = element._ensureArray(
        payload[element._getAmfKey('http://a.ml/vocabularies/http#schema')])[0];
      const result = element._resolve(schema);
      assert.typeOf(result[element._getAmfKey('http://www.w3.org/ns/shacl#name')], 'array');
    });
  });
});
</script>
</body>
</html>
