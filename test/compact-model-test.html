<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, minimum-scale=1, initial-scale=1, user-scalable=yes">
  <title>amf-helper-mixin test</title>
  <script src="../../webcomponentsjs/webcomponents-loader.js"></script>
  <script src="../../web-component-tester/browser.js"></script>
  <link rel="import" href="../../arc-polyfills/arc-polyfills.html">
  <link rel="import" href="test-element.html">
  <script src="amf-loader.js"></script>
</head>
<body>
  <test-fixture id="Basic">
    <template>
      <test-element></test-element>
    </template>
  </test-fixture>

  <script>
  /* global AmfLoader */
  suite('Compact model tests', () => {
    let element;
    let model;
    suiteSetup(() => {
      return AmfLoader.load({
        isCompact: true
      })
      .then((data) => {
        model = data;
      });
    });

    suite('_getAmfKey()', function() {
      setup(() => {
        element = fixture('Basic');
      });
      const key = 'http://schema.org/description';
      test('Returns a value from context', function() {
        element.amfModel = model;
        const result = element._getAmfKey(key);
        assert.equal(result, 'desc');
      });

      test('Returns the key if no AMF', function() {
        const result = element._getAmfKey(key);
        assert.equal(result, key);
      });

      test('Returns the key if value not found', function() {
        const result = element._getAmfKey('non-existing');
        assert.equal(result, 'non-existing');
      });
    });

    suite('_ensureAmfModel()', () => {
      setup(() => {
        element = fixture('Basic');
        element.amfModel = model;
      });

      test('Returns model', () => {
        const result = element._ensureAmfModel(model);
        assert.typeOf(result, 'object');
      });
    });

    suite('_getValue()', () => {
      setup(() => {
        element = fixture('Basic');
      });

      test('Returns the value', () => {
        element.amfModel = model;
        const key = 'http://a.ml/vocabularies/http#scheme';
        const result = element._getValue({
          scheme: [{
            '@value': 'test'
          }]
        }, key);
        assert.equal(result, 'test');
      });

      test('Returns undefined if no model', () => {
        const key = 'http://a.ml/vocabularies/http#scheme';
        const result = element._getValue({
          scheme: [{
            '@value': 'test'
          }]
        }, key);
        assert.isUndefined(result);
      });
    });

    suite('_getValueArray()', () => {
      setup(() => {
        element = fixture('Basic');
      });

      test('Returns the values', () => {
        element.amfModel = model;
        const key = 'http://a.ml/vocabularies/http#scheme';
        const result = element._getValueArray({
          scheme: [{
            '@value': 'test'
          }, {
            '@value': 'test2'
          }]
        }, key);
        assert.deepEqual(result, ['test', 'test2']);
      });

      test('Returns undefined if no model', () => {
        const key = 'http://a.ml/vocabularies/http#scheme';
        const result = element._getValueArray({
          scheme: [{
            '@value': 'test'
          }, {
            '@value': 'test2'
          }]
        }, key);
        assert.isUndefined(result);
      });
    });

    suite('_hasType()', () => {
      setup(() => {
        element = fixture('Basic');
        element.amfModel = model;
      });

      test('Returns true for compact type', () => {
        assert.isTrue(element._hasType({
          '@type': ['shapesShape']
        }, 'http://a.ml/vocabularies/shapes#Shape'));
      });
    });

    suite('_hasProperty()', () => {
      setup(() => {
        element = fixture('Basic');
        element.amfModel = model;
      });

      test('Returns true if have a property', () => {
        const prop = 'http://a.ml/vocabularies/shapes#items';
        assert.isTrue(element._hasProperty({
          a: 'test',
          b: 'test',
          items: 'test'
        }, prop));
      });
    });

    suite('_computePropertyArray()', () => {
      setup(() => {
        element = fixture('Basic');
        element.amfModel = model;
      });

      test('Returns array for an item', () => {
        const result = element._computePropertyArray({
          references: ['a', 'b', 'c']
        }, 'http://a.ml/vocabularies/document#references');
        assert.deepEqual(result, ['a', 'b', 'c']);
      });
    });

    suite('_computeDescription()', () => {
      setup(() => {
        element = fixture('Basic');
        element.amfModel = model;
      });

      test('Returns undefined if no description key', () => {
        assert.equal(element._computeDescription({
          'desc': [{
            '@value': ['test']
          }]
        }), 'test');
      });
    });

    suite('_computeEncodes()', () => {
      setup(() => {
        element = fixture('Basic');
        element.amfModel = model;
      });

      test('Returns an object from AMF model', () => {
        const result = element._computeEncodes(model);
        assert.typeOf(result, 'object');
      });
    });

    suite('_computeDeclares()', () => {
      setup(() => {
        element = fixture('Basic');
        element.amfModel = model;
      });

      test('Returns an array from AMF model', () => {
        const result = element._computeDeclares(model);
        assert.typeOf(result, 'array');
      });

      test('Returns all items in the array', () => {
        const result = element._computeDeclares(model);
        assert.lengthOf(result, 17);
      });
    });

    suite('_computeReferences()', () => {
      setup(() => {
        element = fixture('Basic');
        element.amfModel = model;
      });

      test('Returns an array from AMF model', () => {
        const result = element._computeReferences(model);
        assert.typeOf(result, 'array');
      });

      test('Returns all items in the array', () => {
        const result = element._computeReferences(model);
        assert.lengthOf(result, 8);
      });
    });

    suite('_computeWebApi()', () => {
      setup(() => {
        element = fixture('Basic');
        element.amfModel = model;
      });

      test('Returns an object from AMF model', () => {
        const result = element._computeWebApi(model);
        assert.typeOf(result, 'object');
      });
    });

    suite('_computeServer()', () => {
      setup(() => {
        element = fixture('Basic');
        element.amfModel = model;
      });

      test('Returns an object from AMF model', () => {
        const result = element._computeServer(model);
        assert.typeOf(result, 'object');
      });
    });

    suite('_computeProtocols()', () => {
      setup(() => {
        element = fixture('Basic');
        element.amfModel = model;
      });

      test('Returns array with values', () => {
        const result = element._computeProtocols(model);
        assert.typeOf(result, 'array');
        assert.deepEqual(result, ['HTTPS']);
      });
    });

    suite('_computeExpects()', () => {
      let operation;
      let noExpectsOperation;
      suiteSetup(() => {
        element = fixture('Basic');
        element.amfModel = model;
        const endpoint = element._computeEndpointModel(
          element._computeWebApi(model),
          'file://test/demo-api/demo-api.raml#/web-api/end-points/%2Fchanges%2Fwatch'
        );
        const opKey = element._getAmfKey('http://www.w3.org/ns/hydra/core#supportedOperation');
        operation = element._ensureArray(endpoint[opKey])[0];
        noExpectsOperation = element._ensureArray(endpoint[opKey])[1];
      });

      test('Returns undefined if operation does not have "expects"', () => {
        assert.isUndefined(element._computeExpects(noExpectsOperation));
      });

      test('Returns object for an operation', () => {
        const result = element._computeExpects(operation);
        assert.typeOf(result, 'object');
      });
    });

    suite('_computeEndpoints()', () => {
      let webApi;
      suiteSetup(() => {
        element = fixture('Basic');
        element.amfModel = model;
        webApi = element._computeWebApi(model);
      });

      test('Returns a loist of endpoints', () => {
        const result = element._computeEndpoints(webApi);
        assert.typeOf(result, 'array');
        assert.lengthOf(result, 34);
      });
    });

    suite('_computeEndpointModel()', () => {
      let webApi;
      suiteSetup(() => {
        element = fixture('Basic');
        element.amfModel = model;
        webApi = element._computeWebApi(model);
      });

      test('Returns object for endpoint', () => {
        const result = element._computeEndpointModel(webApi,
          'file://test/demo-api/demo-api.raml#/web-api/end-points/%2Fchanges%2Fwatch');
        assert.typeOf(result, 'object');
        assert.equal(result['@type'][0], 'http://a.ml/vocabularies/http#EndPoint');
      });
    });

    suite('_computeMethodModel()', () => {
      let webApi;
      suiteSetup(() => {
        element = fixture('Basic');
        element.amfModel = model;
        webApi = element._computeWebApi(model);
      });

      test('Returns object for method', () => {
        const result = element._computeMethodModel(webApi,
        'file://test/demo-api/demo-api.raml#/web-api/end-points/%2FpermissionIds%2F%7Bemail%7D/get');
        assert.typeOf(result, 'object');
        const key = element._getAmfKey('http://www.w3.org/ns/hydra/core#Operation');
        assert.equal(result['@type'][0], key);
      });
    });

    suite('_computeType()', () => {
      let references;
      let declares;
      suiteSetup(() => {
        element = fixture('Basic');
        element.amfModel = model;
        declares = element._computeDeclares(model);
        references = element._computeReferences(model);
      });

      test('Returns type in declarations', () => {
        const result = element._computeType(declares, undefined,
          'file://test/demo-api/types/app-person.raml#/type');
        assert.typeOf(result, 'object');
        const key = element._getAmfKey('http://www.w3.org/ns/shacl#NodeShape');
        assert.equal(result['@type'][0], key);
      });

      test('Returns type in references (library)', () => {
        const result = element._computeType(declares, references,
          'file://test/demo-api/library.raml#/declarations/types/TypeFromLibray');
        assert.typeOf(result, 'object');
        const key = element._getAmfKey('http://www.w3.org/ns/shacl#NodeShape');
        assert.equal(result['@type'][0], key);
      });
    });

    suite('_getLinkTarget()', () => {
      suiteSetup(() => {
        element = fixture('Basic');
        element.amfModel = model;
      });

      test('Computes reference', () => {
        const result = element._getLinkTarget(model,
          'file://test/demo-api/demo-api.raml#/declarations/types/SchemaPerson');
        assert.typeOf(result, 'object');
      });

      test('Reference is resolved', () => {
        const result = element._getLinkTarget(model,
          'file://test/demo-api/demo-api.raml#/declarations/types/SchemaPerson');
        const key = element._getAmfKey('http://a.ml/vocabularies/document#raw');
        assert.ok(result[key]);
      });

      test('Deep reference is resolved', () => {
        const result = element._getLinkTarget(model,
          'file://test/demo-api/demo-api.raml#/declarations/types/SchemaPerson');
        const exKey = element._getAmfKey('http://a.ml/vocabularies/document#examples');
        const example = element._ensureArray(result[exKey])[0];
        const svKey = element._getAmfKey('http://a.ml/vocabularies/document#structuredValue');
        assert.ok(example[svKey]);
      });
    });

    suite('_getReferenceId()', () => {
      suiteSetup(() => {
        element = fixture('Basic');
        element.amfModel = model;
      });

      test('Computes reference', () => {
        const result = element._getReferenceId(model,
          'file://test/demo-api/schemas/person.json#/external');
        assert.typeOf(result, 'object');
      });
    });

    suite('_resolve()', () => {
      let webApi;
      suiteSetup(() => {
        element = fixture('Basic');
        element.amfModel = model;
        webApi = element._computeWebApi(model);
      });

      test('Resolves link target', () => {
        const endpoint = element._computeEndpointModel(webApi,
          'file://test/demo-api/demo-api.raml#/web-api/end-points/%2FreferenceId');
        const op = element._ensureArray(
          endpoint[element._getAmfKey('http://www.w3.org/ns/hydra/core#supportedOperation')])[0];
        const expects = element._ensureArray(
          op[element._getAmfKey('http://www.w3.org/ns/hydra/core#expects')])[0];
        const payload = element._ensureArray(
          expects[element._getAmfKey('http://a.ml/vocabularies/http#payload')])[0];
        const schema = element._ensureArray(
          payload[element._getAmfKey('http://a.ml/vocabularies/http#schema')])[0];
        const result = element._resolve(schema);
        assert.ok(result[element._getAmfKey('http://www.w3.org/ns/shacl#name')]);
        assert.ok(result[element._getAmfKey('http://a.ml/vocabularies/document#raw')]);
      });
    });
  });
  </script>
</body>
</html>
